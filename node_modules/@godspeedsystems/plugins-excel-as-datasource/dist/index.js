"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_CONFIG = exports.CONFIG_FILE_NAME = exports.Type = exports.SourceType = exports.DataSource = void 0;
const core_1 = require("@godspeedsystems/core");
const Excel = __importStar(require("xlsx"));
const path_1 = __importDefault(require("path"));
const uuid_1 = require("uuid");
const fs_1 = __importDefault(require("fs"));
class DataSource extends core_1.GSDataSource {
    initClient() {
        return __awaiter(this, void 0, void 0, function* () {
            return Excel;
        });
    }
    getFilePath() {
        return this.config.filepath;
    }
    ensureFileExists() {
        return __awaiter(this, void 0, void 0, function* () {
            const filePath = this.getFilePath();
            // Check if the file exists
            if (!fs_1.default.existsSync(filePath)) {
                // If not, create the file
                const sheet = Excel.utils.json_to_sheet([]);
                const workbook = Excel.utils.book_new();
                Excel.utils.book_append_sheet(workbook, sheet, "Sheet1");
                Excel.writeFile(workbook, filePath);
                console.log('File created successfully.');
            }
        });
    }
    readData(Excel) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureFileExists(); // Ensure file exists before reading
            const excelFile = path_1.default.join(this.config.filepath);
            const workbook = Excel.readFile(excelFile);
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const data = Excel.utils.sheet_to_json(sheet);
            return data;
        });
    }
    writeData(Excel, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const excelFile = path_1.default.join(__dirname, this.config.filename);
            const sheet = Excel.utils.json_to_sheet(data);
            const workbook = Excel.utils.book_new();
            Excel.utils.book_append_sheet(workbook, sheet, "Sheet1");
            Excel.writeFile(workbook, excelFile);
        });
    }
    createData(data) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureFileExists(); // Ensure file exists before reading
            const _data = yield this.readData(Excel);
            const newData = Object.assign({ id: (0, uuid_1.v4)() }, data);
            _data.push(newData);
            yield this.writeData(Excel, _data);
            return "Data successfully added";
        });
    }
    searchData() {
        return __awaiter(this, void 0, void 0, function* () {
            const _data = yield this.readData(Excel);
            return _data;
        });
    }
    updateData(id, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const _data = yield this.readData(Excel);
            const updateIndex = _data.findIndex((item) => item.id === id);
            if (updateIndex !== -1) {
                _data[updateIndex] = Object.assign({ id }, data);
                yield this.writeData(Excel, _data);
                return "Data updated successfully";
            }
            else {
                return "ID not found";
            }
        });
    }
    getOneData(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const _data = yield this.readData(Excel);
            const index = _data.findIndex((item) => item.id === id);
            if (index !== -1) {
                const one = _data[index];
                return one;
            }
            else {
                return "ID not found";
            }
        });
    }
    deleteData(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const _data = yield this.readData(Excel);
            const deleteIndex = _data.findIndex((item) => item.id === id);
            if (deleteIndex !== -1) {
                _data.splice(deleteIndex, 1);
                yield this.writeData(Excel, _data);
                return "Data deleted successfully";
            }
            else {
                return "ID not found";
            }
        });
    }
    execute(ctx, args) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { meta: { fnNameInWorkflow }, } = args;
                const method = fnNameInWorkflow.split(".")[2];
                switch (method) {
                    case "create":
                        return this.createData(args.data);
                    case "search":
                        return this.searchData();
                    case "update":
                        return this.updateData(args.id, args.data);
                    case "one":
                        return this.getOneData(args.id);
                    case "delete":
                        return this.deleteData(args.id);
                    default:
                        return "Invalid method";
                }
            }
            catch (error) {
                throw error;
            }
        });
    }
}
exports.default = DataSource;
exports.DataSource = DataSource;
const SourceType = 'DS';
exports.SourceType = SourceType;
const Type = "excel"; // this is the loader file of the plugin, So the final loader file will be `types/${Type.js}`
exports.Type = Type;
const CONFIG_FILE_NAME = "excel"; // in case of event source, this also works as event identifier, and in case of datasource works as datasource name
exports.CONFIG_FILE_NAME = CONFIG_FILE_NAME;
const DEFAULT_CONFIG = {};
exports.DEFAULT_CONFIG = DEFAULT_CONFIG;
//# sourceMappingURL=index.js.map